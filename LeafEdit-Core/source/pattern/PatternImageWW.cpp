/*
*   This file is part of LeafEdit-Core
*   Copyright (C) 2020 Universal-Team
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*
*   Additional Terms 7.b and 7.c of GPLv3 apply to this file:
*       * Requiring preservation of specified reasonable legal notices or
*         author attributions in that material or in the Appropriate Legal
*         Notices displayed by works containing it.
*       * Prohibiting misrepresentation of the origin of that material,
*         or requiring that modified versions of such material be marked in
*         reasonable ways as different from the original version.
*/

#include "msg.hpp"
#include "PatternImageWW.hpp"
#include "saveUtils.hpp"
#include "stringUtils.hpp"

#include <algorithm> // For std::max.
#include <cstring>
#include <unistd.h>

// ARGB.

static const u32 PaletteColors[] = {
	0xFF0000FF, 0xFF3173FF, 0xFF00ADFF, 0xFF00FFFF, 0xFF00FFAD, 0xFF00FF52, 0xFF00FF00, 0xFF52AD00, 0xFFAD5200, 0xFFFF0000, 0xFFFF0052, 0xFFFF00AD, 0xFFFF00FF, 0xFF000000, 0xFFFFFFFF,
	0xFF7B7BFF, 0xFF7BB5FF, 0xFF7BE7FF, 0xFF7BFFFF, 0xFF7BFFDE, 0xFF7BFFAD, 0xFF7BFF7B, 0xFF84AD52, 0xFFAD8452, 0xFFFF7B7B, 0xFFFF7BB5, 0xFFFF7BE7, 0xFFFF7BFF, 0xFF000000, 0xFFFFFFFF,
	0xFF0000A5, 0xFF0031A5, 0xFF0073A5, 0xFF00A5A5, 0xFF00A573, 0xFF00A531, 0xFF00A500, 0xFF215200, 0xFF522100, 0xFFA50000, 0xFFA50031, 0xFFA50073, 0xFFA500A5, 0xFF000000, 0xFFFFFFFF,
	0xFF009C00, 0xFF6BCE5A, 0xFFDEFFB5, 0xFF6B9C00, 0xFFA5CE52, 0xFFD6FFAD, 0xFFAD5200, 0xFFD68429, 0xFFFFAD5A, 0xFFFF0000, 0xFFFF6B4A, 0xFFDE4A31, 0xFFB52118, 0xFF8C0000, 0xFFFFFFFF,
	0xFF0073AD, 0xFF42ADD6, 0xFF8CDEFF, 0xFF3908FF, 0xFF6B4AFF, 0xFF9C94FF, 0xFFFF00AD, 0xFFFF63D6, 0xFFFFCEFF, 0xFF9CBDFF, 0xFF7394DE, 0xFF4A63BD, 0xFF21399C, 0xFF00107B, 0xFFFFFFFF,
	0xFF0000FF, 0xFF0052FF, 0xFF5AB5FF, 0xFFADEFFF, 0xFF00107B, 0xFF314AA5, 0xFF6B84D6, 0xFF9CBDFF, 0xFFFFAD5A, 0xFFFFC684, 0xFFFFE7AD, 0xFFFFFFD6, 0xFF6B6B6B, 0xFF000000, 0xFFFFFFFF,
	0xFF00FF00, 0xFF42FF42, 0xFF8CFF8C, 0xFFD6FFD6, 0xFFFF0000, 0xFFFF4242, 0xFFFF8C8C, 0xFFFFD6D6, 0xFF0000FF, 0xFF4242FF, 0xFF8C8CFF, 0xFFD6D6FF, 0xFF6B6B6B, 0xFF000000, 0xFFFFFFFF,
	0xFF003100, 0xFF426342, 0xFF849C84, 0xFFC6D6C6, 0xFF00107B, 0xFF294AA5, 0xFF5A8CD6, 0xFF8CC6FF, 0xFF00B5D6, 0xFF39CEE7, 0xFF7BDEF7, 0xFFBDF7FF, 0xFF6B6B6B, 0xFF000000, 0xFFFFFFFF,
	0xFFFF0000, 0xFF0000FF, 0xFF00FFFF, 0xFFFF4242, 0xFF4242FF, 0xFF42FFFF, 0xFFFF8C8C, 0xFF8C8CFF, 0xFF8CFFFF, 0xFFFFD6D6, 0xFFD6D6FF, 0xFFD6FFFF, 0xFF6B6B6B, 0xFF000000, 0xFFFFFFFF,
	0xFF00FF00, 0xFFFF0000, 0xFFFF00FF, 0xFF42FF42, 0xFFFF4242, 0xFFFF42FF, 0xFF8CFF8C, 0xFFFF8C8C, 0xFFFF8CFF, 0xFFD6FFD6, 0xFFFFD6D6, 0xFFFFD6FF, 0xFF6B6B6B, 0xFF000000, 0xFFFFFFFF,
	0xFF0000FF, 0xFF007BFF, 0xFF00FFFF, 0xFF00FF84, 0xFF00FF00, 0xFF7B8400, 0xFFFF0000, 0xFFFF007B, 0xFFFF94FF, 0xFF00B5D6, 0xFF0010BD, 0xFF00105A, 0xFF6B6B6B, 0xFF000000, 0xFFFFFFFF,
	0xFF639410, 0xFF527B08, 0xFF398C10, 0xFF319C31, 0xFF4AA5CE, 0xFF3994CE, 0xFF4A8CBD, 0xFF318CD6, 0xFF4A73AD, 0xFF315A8C, 0xFF29426B, 0xFFFFEF84, 0xFFEFCE31, 0xFFC6A500, 0xFFFFFFFF,
	0xFFE7DED6, 0xFFDECEB5, 0xFFEFEFE7, 0xFFF7F7F7, 0xFF7B7384, 0xFF6B8C94, 0xFF637B84, 0xFF5A849C, 0xFFB59C73, 0xFF2929FF, 0xFF00FFFF, 0xFFFF2194, 0xFFBD9C00, 0xFF000000, 0xFFFFFFFF,
	0xFFFFFFFF, 0xFFEFEFF7, 0xFFDEDEE7, 0xFFCECED6, 0xFFB5B5C6, 0xFFA5A5B5, 0xFF9494A5, 0xFF84849C, 0xFF6B6B8C, 0xFF5A5A7B, 0xFF4A4A6B, 0xFF31315A, 0xFF21214A, 0xFF101042, 0xFF000031,
	0xFFFFFFFF, 0xFFEFEFEF, 0xFFDEDEDE, 0xFFCECECE, 0xFFB5B5B5, 0xFFA5A5A5, 0xFF949494, 0xFF848484, 0xFF6B6B6B, 0xFF5A5A5A, 0xFF4A4A4A, 0xFF313131, 0xFF212121, 0xFF101010, 0xFF000000,
	0xFF7B8CFF, 0xFF0000FF, 0xFF007BFF, 0xFF00FFFF, 0xFF008400, 0xFF00FF00, 0xFFFF0000, 0xFFFF9C00, 0xFFFF00D6, 0xFFFF6BFF, 0xFF00009C, 0xFF0094FF, 0xFF94BDFF, 0xFF000000, 0xFFFFFFFF
};

// RGBA.
/*
static const u32 PaletteColors[] = {
	0x0000FFFF, 0x3173FFFF, 0xFF00ADFF, 0x00FFFFFF, 0x00FFADFF, 0x00FF52FF, 0x00FF00FF, 0x52AD00FF, 0xAD5200FF, 0xFF0000FF, 0xFF0052FF, 0xFF00ADFF, 0xFF00FFFF, 0x000000FF, 0xFFFFFFFF,
	0x7B7BFFFF, 0x7BB5FFFF, 0xFF7BE7FF, 0x7BFFFFFF, 0x7BFFDEFF, 0x7BFFADFF, 0x7BFF7BFF, 0x84AD52FF, 0xAD8452FF, 0xFF7B7BFF, 0xFF7BB5FF, 0xFF7BE7FF, 0xFF7BFFFF, 0x000000FF, 0xFFFFFFFF,
	0x0000A5FF, 0x0031A5FF, 0xFF0073A5, 0x00A5A5FF, 0x00A573FF, 0x00A531FF, 0x00A500FF, 0x215200FF, 0x522100FF, 0xA50000FF, 0xA50031FF, 0xA50073FF, 0xA500A5FF, 0x000000FF, 0xFFFFFFFF,
	0x009C00FF, 0x6BCE5AFF, 0xFFDEFFB5, 0x6B9C00FF, 0xA5CE52FF, 0xD6FFADFF, 0xAD5200FF, 0xD68429FF, 0xFFAD5AFF, 0xFF0000FF, 0xFF6B4AFF, 0xDE4A31FF, 0xB52118FF, 0x8C0000FF, 0xFFFFFFFF,
	0x0073ADFF, 0x42ADD6FF, 0xFF8CDEFF, 0x3908FFFF, 0x6B4AFFFF, 0x9C94FFFF, 0xFF00ADFF, 0xFF63D6FF, 0xFFCEFFFF, 0x9CBDFFFF, 0x7394DEFF, 0x4A63BDFF, 0x21399CFF, 0x00107BFF, 0xFFFFFFFF,
	0x0000FFFF, 0x0052FFFF, 0xFF5AB5FF, 0xADEFFFFF, 0x00107BFF, 0x314AA5FF, 0x6B84D6FF, 0x9CBDFFFF, 0xFFAD5AFF, 0xFFC684FF, 0xFFE7ADFF, 0xFFFFD6FF, 0x6B6B6BFF, 0x000000FF, 0xFFFFFFFF,
	0x00FF00FF, 0x42FF42FF, 0xFF8CFF8C, 0xD6FFD6FF, 0xFF0000FF, 0xFF4242FF, 0xFF8C8CFF, 0xFFD6D6FF, 0x0000FFFF, 0x4242FFFF, 0x8C8CFFFF, 0xD6D6FFFF, 0x6B6B6BFF, 0x000000FF, 0xFFFFFFFF,
	0x003100FF, 0x426342FF, 0xFF849C84, 0xC6D6C6FF, 0x00107BFF, 0x294AA5FF, 0x5A8CD6FF, 0x8CC6FFFF, 0x00B5D6FF, 0x39CEE7FF, 0x7BDEF7FF, 0xBDF7FFFF, 0x6B6B6BFF, 0x000000FF, 0xFFFFFFFF,
	0xFF0000FF, 0x0000FFFF, 0xFF00FFFF, 0xFF4242FF, 0x4242FFFF, 0x42FFFFFF, 0xFF8C8CFF, 0x8C8CFFFF, 0x8CFFFFFF, 0xFFD6D6FF, 0xD6D6FFFF, 0xD6FFFFFF, 0x6B6B6BFF, 0x000000FF, 0xFFFFFFFF,
	0x00FF00FF, 0xFF0000FF, 0xFFFF00FF, 0x42FF42FF, 0xFF4242FF, 0xFF42FFFF, 0x8CFF8CFF, 0xFF8C8CFF, 0xFF8CFFFF, 0xD6FFD6FF, 0xFFD6D6FF, 0xFFD6FFFF, 0x6B6B6BFF, 0x000000FF, 0xFFFFFFFF,
	0x0000FFFF, 0x007BFFFF, 0xFF00FFFF, 0x00FF84FF, 0x00FF00FF, 0x7B8400FF, 0xFF0000FF, 0xFF007BFF, 0xFF94FFFF, 0x00B5D6FF, 0x0010BDFF, 0x00105AFF, 0x6B6B6BFF, 0x000000FF, 0xFFFFFFFF,
	0x639410FF, 0x527B08FF, 0xFF398C10, 0x319C31FF, 0x4AA5CEFF, 0x3994CEFF, 0x4A8CBDFF, 0x318CD6FF, 0x4A73ADFF, 0x315A8CFF, 0x29426BFF, 0xFFEF84FF, 0xEFCE31FF, 0xC6A500FF, 0xFFFFFFFF,
	0xE7DED6FF, 0xDECEB5FF, 0xFFEFEFE7, 0xF7F7F7FF, 0x7B7384FF, 0x6B8C94FF, 0x637B84FF, 0x5A849CFF, 0xB59C73FF, 0x2929FFFF, 0x00FFFFFF, 0xFF2194FF, 0xBD9C00FF, 0x000000FF, 0xFFFFFFFF,
	0xFFFFFFFF, 0xEFEFF7FF, 0xFFDEDEE7, 0xCECED6FF, 0xB5B5C6FF, 0xA5A5B5FF, 0x9494A5FF, 0x84849CFF, 0x6B6B8CFF, 0x5A5A7BFF, 0x4A4A6BFF, 0x31315AFF, 0x21214AFF, 0x101042FF, 0x000031FF,
	0xFFFFFFFF, 0xEFEFEFFF, 0xFFDEDEDE, 0xCECECEFF, 0xB5B5B5FF, 0xA5A5A5FF, 0x949494FF, 0x848484FF, 0x6B6B6BFF, 0x5A5A5AFF, 0x4A4A4AFF, 0x313131FF, 0x212121FF, 0x101010FF, 0x000000FF,
	0x7B8CFFFF, 0x0000FFFF, 0xFF007BFF, 0x00FFFFFF, 0x008400FF, 0x00FF00FF, 0xFF0000FF, 0xFF9C00FF, 0xFF00D6FF, 0xFF6BFFFF, 0x00009CFF, 0x0094FFFF, 0x94BDFFFF, 0x000000FF, 0xFFFFFFFF
};*/

// Refresh buffer.
void PatternImageWW::refresh() {
	this->valid = false;
	this->patternRawBuffer = std::unique_ptr<u8[]>(new u8[0x400]);

	// Palette Index.
	this->paletteIndex = (u8)(((this->paletteData()[0]) & 0xF0) >> 4);

	for(uint i = 0; i < 0x200; i++) {
		this->patternRawBuffer[i * 2] = (u8)(this->patternData()[i] & 0x0F);
		this->patternRawBuffer[i * 2 + 1] = (u8)((this->patternData()[i] & 0xF0) >> 4);
	}

	for (int i = 0; i < 16; i++) {
		this->colors[i] = {PaletteColors[(this->paletteIndex * 15) + i]};
	}
	

	this->valid = true;
}

u32 PatternImageWW::getPixelColor(int x, int y) {
	if (this->valid) {
		if (this->rawData() != nullptr) {
			int colorIndex = std::max(0, this->rawData()[x + (y * 32)] - 1); // Get the higher number of it.
			return this->colors[colorIndex];
		} else {
			return 0;
		}
	} else {
		return 0;
	}
}

u32 PatternImageWW::getRawPixelColor(int index) {
	if (this->valid) {
		if (this->rawData() != nullptr) {
			int colorIndex = std::max(0, this->rawData()[index] - 1); // Get the higher number of it.
			return this->colors[colorIndex];
		} else {
			return 0;
		}
	} else {
		return 0;
	}
}